/*
  Kubernetes

  No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

  The version of the OpenAPI document: v1.26.9+aa37255

  Generated by OpenAPI Generator: https://openapi-generator.tech
*/

syntax = "proto3";

package openapitools.services.corev1service;

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import public "models/io_k8s_api_authentication_v1_token_request.proto";
import public "models/io_k8s_api_autoscaling_v1_scale.proto";
import public "models/io_k8s_api_core_v1_binding.proto";
import public "models/io_k8s_api_core_v1_component_status.proto";
import public "models/io_k8s_api_core_v1_component_status_list.proto";
import public "models/io_k8s_api_core_v1_config_map.proto";
import public "models/io_k8s_api_core_v1_config_map_list.proto";
import public "models/io_k8s_api_core_v1_endpoints.proto";
import public "models/io_k8s_api_core_v1_endpoints_list.proto";
import public "models/io_k8s_api_core_v1_event.proto";
import public "models/io_k8s_api_core_v1_event_list.proto";
import public "models/io_k8s_api_core_v1_limit_range.proto";
import public "models/io_k8s_api_core_v1_limit_range_list.proto";
import public "models/io_k8s_api_core_v1_namespace.proto";
import public "models/io_k8s_api_core_v1_namespace_list.proto";
import public "models/io_k8s_api_core_v1_node.proto";
import public "models/io_k8s_api_core_v1_node_list.proto";
import public "models/io_k8s_api_core_v1_persistent_volume.proto";
import public "models/io_k8s_api_core_v1_persistent_volume_claim.proto";
import public "models/io_k8s_api_core_v1_persistent_volume_claim_list.proto";
import public "models/io_k8s_api_core_v1_persistent_volume_list.proto";
import public "models/io_k8s_api_core_v1_pod.proto";
import public "models/io_k8s_api_core_v1_pod_list.proto";
import public "models/io_k8s_api_core_v1_pod_template.proto";
import public "models/io_k8s_api_core_v1_pod_template_list.proto";
import public "models/io_k8s_api_core_v1_replication_controller.proto";
import public "models/io_k8s_api_core_v1_replication_controller_list.proto";
import public "models/io_k8s_api_core_v1_resource_quota.proto";
import public "models/io_k8s_api_core_v1_resource_quota_list.proto";
import public "models/io_k8s_api_core_v1_secret.proto";
import public "models/io_k8s_api_core_v1_secret_list.proto";
import public "models/io_k8s_api_core_v1_service.proto";
import public "models/io_k8s_api_core_v1_service_account.proto";
import public "models/io_k8s_api_core_v1_service_account_list.proto";
import public "models/io_k8s_api_core_v1_service_list.proto";
import public "models/io_k8s_api_policy_v1_eviction.proto";
import public "models/io_k8s_apimachinery_pkg_apis_meta_v1_api_resource_list.proto";
import public "models/io_k8s_apimachinery_pkg_apis_meta_v1_delete_options.proto";
import public "models/io_k8s_apimachinery_pkg_apis_meta_v1_status.proto";
import public "models/io_k8s_apimachinery_pkg_apis_meta_v1_watch_event.proto";


service CoreV1Service {
  rpc ConnectCoreV1DeleteNamespacedPodProxy (ConnectCoreV1DeleteNamespacedPodProxyRequest) returns (ConnectCoreV1DeleteNamespacedPodProxyResponse);

  rpc ConnectCoreV1DeleteNamespacedPodProxyWithPath (ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1DeleteNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1DeleteNamespacedServiceProxy (ConnectCoreV1DeleteNamespacedServiceProxyRequest) returns (ConnectCoreV1DeleteNamespacedServiceProxyResponse);

  rpc ConnectCoreV1DeleteNamespacedServiceProxyWithPath (ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1DeleteNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1DeleteNodeProxy (ConnectCoreV1DeleteNodeProxyRequest) returns (ConnectCoreV1DeleteNodeProxyResponse);

  rpc ConnectCoreV1DeleteNodeProxyWithPath (ConnectCoreV1DeleteNodeProxyWithPathRequest) returns (ConnectCoreV1DeleteNodeProxyWithPathResponse);

  rpc ConnectCoreV1GetNamespacedPodAttach (ConnectCoreV1GetNamespacedPodAttachRequest) returns (ConnectCoreV1GetNamespacedPodAttachResponse);

  rpc ConnectCoreV1GetNamespacedPodExec (ConnectCoreV1GetNamespacedPodExecRequest) returns (ConnectCoreV1GetNamespacedPodExecResponse);

  rpc ConnectCoreV1GetNamespacedPodPortforward (ConnectCoreV1GetNamespacedPodPortforwardRequest) returns (ConnectCoreV1GetNamespacedPodPortforwardResponse);

  rpc ConnectCoreV1GetNamespacedPodProxy (ConnectCoreV1GetNamespacedPodProxyRequest) returns (ConnectCoreV1GetNamespacedPodProxyResponse);

  rpc ConnectCoreV1GetNamespacedPodProxyWithPath (ConnectCoreV1GetNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1GetNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1GetNamespacedServiceProxy (ConnectCoreV1GetNamespacedServiceProxyRequest) returns (ConnectCoreV1GetNamespacedServiceProxyResponse);

  rpc ConnectCoreV1GetNamespacedServiceProxyWithPath (ConnectCoreV1GetNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1GetNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1GetNodeProxy (ConnectCoreV1GetNodeProxyRequest) returns (ConnectCoreV1GetNodeProxyResponse);

  rpc ConnectCoreV1GetNodeProxyWithPath (ConnectCoreV1GetNodeProxyWithPathRequest) returns (ConnectCoreV1GetNodeProxyWithPathResponse);

  rpc ConnectCoreV1HeadNamespacedPodProxy (ConnectCoreV1HeadNamespacedPodProxyRequest) returns (ConnectCoreV1HeadNamespacedPodProxyResponse);

  rpc ConnectCoreV1HeadNamespacedPodProxyWithPath (ConnectCoreV1HeadNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1HeadNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1HeadNamespacedServiceProxy (ConnectCoreV1HeadNamespacedServiceProxyRequest) returns (ConnectCoreV1HeadNamespacedServiceProxyResponse);

  rpc ConnectCoreV1HeadNamespacedServiceProxyWithPath (ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1HeadNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1HeadNodeProxy (ConnectCoreV1HeadNodeProxyRequest) returns (ConnectCoreV1HeadNodeProxyResponse);

  rpc ConnectCoreV1HeadNodeProxyWithPath (ConnectCoreV1HeadNodeProxyWithPathRequest) returns (ConnectCoreV1HeadNodeProxyWithPathResponse);

  rpc ConnectCoreV1OptionsNamespacedPodProxy (ConnectCoreV1OptionsNamespacedPodProxyRequest) returns (ConnectCoreV1OptionsNamespacedPodProxyResponse);

  rpc ConnectCoreV1OptionsNamespacedPodProxyWithPath (ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1OptionsNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1OptionsNamespacedServiceProxy (ConnectCoreV1OptionsNamespacedServiceProxyRequest) returns (ConnectCoreV1OptionsNamespacedServiceProxyResponse);

  rpc ConnectCoreV1OptionsNamespacedServiceProxyWithPath (ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1OptionsNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1OptionsNodeProxy (ConnectCoreV1OptionsNodeProxyRequest) returns (ConnectCoreV1OptionsNodeProxyResponse);

  rpc ConnectCoreV1OptionsNodeProxyWithPath (ConnectCoreV1OptionsNodeProxyWithPathRequest) returns (ConnectCoreV1OptionsNodeProxyWithPathResponse);

  rpc ConnectCoreV1PatchNamespacedPodProxy (ConnectCoreV1PatchNamespacedPodProxyRequest) returns (ConnectCoreV1PatchNamespacedPodProxyResponse);

  rpc ConnectCoreV1PatchNamespacedPodProxyWithPath (ConnectCoreV1PatchNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1PatchNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1PatchNamespacedServiceProxy (ConnectCoreV1PatchNamespacedServiceProxyRequest) returns (ConnectCoreV1PatchNamespacedServiceProxyResponse);

  rpc ConnectCoreV1PatchNamespacedServiceProxyWithPath (ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1PatchNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1PatchNodeProxy (ConnectCoreV1PatchNodeProxyRequest) returns (ConnectCoreV1PatchNodeProxyResponse);

  rpc ConnectCoreV1PatchNodeProxyWithPath (ConnectCoreV1PatchNodeProxyWithPathRequest) returns (ConnectCoreV1PatchNodeProxyWithPathResponse);

  rpc ConnectCoreV1PostNamespacedPodAttach (ConnectCoreV1PostNamespacedPodAttachRequest) returns (ConnectCoreV1PostNamespacedPodAttachResponse);

  rpc ConnectCoreV1PostNamespacedPodExec (ConnectCoreV1PostNamespacedPodExecRequest) returns (ConnectCoreV1PostNamespacedPodExecResponse);

  rpc ConnectCoreV1PostNamespacedPodPortforward (ConnectCoreV1PostNamespacedPodPortforwardRequest) returns (ConnectCoreV1PostNamespacedPodPortforwardResponse);

  rpc ConnectCoreV1PostNamespacedPodProxy (ConnectCoreV1PostNamespacedPodProxyRequest) returns (ConnectCoreV1PostNamespacedPodProxyResponse);

  rpc ConnectCoreV1PostNamespacedPodProxyWithPath (ConnectCoreV1PostNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1PostNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1PostNamespacedServiceProxy (ConnectCoreV1PostNamespacedServiceProxyRequest) returns (ConnectCoreV1PostNamespacedServiceProxyResponse);

  rpc ConnectCoreV1PostNamespacedServiceProxyWithPath (ConnectCoreV1PostNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1PostNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1PostNodeProxy (ConnectCoreV1PostNodeProxyRequest) returns (ConnectCoreV1PostNodeProxyResponse);

  rpc ConnectCoreV1PostNodeProxyWithPath (ConnectCoreV1PostNodeProxyWithPathRequest) returns (ConnectCoreV1PostNodeProxyWithPathResponse);

  rpc ConnectCoreV1PutNamespacedPodProxy (ConnectCoreV1PutNamespacedPodProxyRequest) returns (ConnectCoreV1PutNamespacedPodProxyResponse);

  rpc ConnectCoreV1PutNamespacedPodProxyWithPath (ConnectCoreV1PutNamespacedPodProxyWithPathRequest) returns (ConnectCoreV1PutNamespacedPodProxyWithPathResponse);

  rpc ConnectCoreV1PutNamespacedServiceProxy (ConnectCoreV1PutNamespacedServiceProxyRequest) returns (ConnectCoreV1PutNamespacedServiceProxyResponse);

  rpc ConnectCoreV1PutNamespacedServiceProxyWithPath (ConnectCoreV1PutNamespacedServiceProxyWithPathRequest) returns (ConnectCoreV1PutNamespacedServiceProxyWithPathResponse);

  rpc ConnectCoreV1PutNodeProxy (ConnectCoreV1PutNodeProxyRequest) returns (ConnectCoreV1PutNodeProxyResponse);

  rpc ConnectCoreV1PutNodeProxyWithPath (ConnectCoreV1PutNodeProxyWithPathRequest) returns (ConnectCoreV1PutNodeProxyWithPathResponse);

  rpc CreateCoreV1Namespace (CreateCoreV1NamespaceRequest) returns (IoK8sApiCoreV1Namespace);

  rpc CreateCoreV1NamespacedBinding (CreateCoreV1NamespacedBindingRequest) returns (IoK8sApiCoreV1Binding);

  rpc CreateCoreV1NamespacedConfigMap (CreateCoreV1NamespacedConfigMapRequest) returns (IoK8sApiCoreV1ConfigMap);

  rpc CreateCoreV1NamespacedEndpoints (CreateCoreV1NamespacedEndpointsRequest) returns (IoK8sApiCoreV1Endpoints);

  rpc CreateCoreV1NamespacedEvent (CreateCoreV1NamespacedEventRequest) returns (IoK8sApiCoreV1Event);

  rpc CreateCoreV1NamespacedLimitRange (CreateCoreV1NamespacedLimitRangeRequest) returns (IoK8sApiCoreV1LimitRange);

  rpc CreateCoreV1NamespacedPersistentVolumeClaim (CreateCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc CreateCoreV1NamespacedPod (CreateCoreV1NamespacedPodRequest) returns (IoK8sApiCoreV1Pod);

  rpc CreateCoreV1NamespacedPodBinding (CreateCoreV1NamespacedPodBindingRequest) returns (IoK8sApiCoreV1Binding);

  rpc CreateCoreV1NamespacedPodEviction (CreateCoreV1NamespacedPodEvictionRequest) returns (IoK8sApiPolicyV1Eviction);

  rpc CreateCoreV1NamespacedPodTemplate (CreateCoreV1NamespacedPodTemplateRequest) returns (IoK8sApiCoreV1PodTemplate);

  rpc CreateCoreV1NamespacedReplicationController (CreateCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc CreateCoreV1NamespacedResourceQuota (CreateCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc CreateCoreV1NamespacedSecret (CreateCoreV1NamespacedSecretRequest) returns (IoK8sApiCoreV1Secret);

  rpc CreateCoreV1NamespacedService (CreateCoreV1NamespacedServiceRequest) returns (IoK8sApiCoreV1Service);

  rpc CreateCoreV1NamespacedServiceAccount (CreateCoreV1NamespacedServiceAccountRequest) returns (IoK8sApiCoreV1ServiceAccount);

  rpc CreateCoreV1NamespacedServiceAccountToken (CreateCoreV1NamespacedServiceAccountTokenRequest) returns (IoK8sApiAuthenticationV1TokenRequest);

  rpc CreateCoreV1Node (CreateCoreV1NodeRequest) returns (IoK8sApiCoreV1Node);

  rpc CreateCoreV1PersistentVolume (CreateCoreV1PersistentVolumeRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc DeleteCoreV1CollectionNamespacedConfigMap (DeleteCoreV1CollectionNamespacedConfigMapRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedEndpoints (DeleteCoreV1CollectionNamespacedEndpointsRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedEvent (DeleteCoreV1CollectionNamespacedEventRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedLimitRange (DeleteCoreV1CollectionNamespacedLimitRangeRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedPersistentVolumeClaim (DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedPod (DeleteCoreV1CollectionNamespacedPodRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedPodTemplate (DeleteCoreV1CollectionNamespacedPodTemplateRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedReplicationController (DeleteCoreV1CollectionNamespacedReplicationControllerRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedResourceQuota (DeleteCoreV1CollectionNamespacedResourceQuotaRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedSecret (DeleteCoreV1CollectionNamespacedSecretRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedService (DeleteCoreV1CollectionNamespacedServiceRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNamespacedServiceAccount (DeleteCoreV1CollectionNamespacedServiceAccountRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionNode (DeleteCoreV1CollectionNodeRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1CollectionPersistentVolume (DeleteCoreV1CollectionPersistentVolumeRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1Namespace (DeleteCoreV1NamespaceRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedConfigMap (DeleteCoreV1NamespacedConfigMapRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedEndpoints (DeleteCoreV1NamespacedEndpointsRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedEvent (DeleteCoreV1NamespacedEventRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedLimitRange (DeleteCoreV1NamespacedLimitRangeRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedPersistentVolumeClaim (DeleteCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc DeleteCoreV1NamespacedPod (DeleteCoreV1NamespacedPodRequest) returns (IoK8sApiCoreV1Pod);

  rpc DeleteCoreV1NamespacedPodTemplate (DeleteCoreV1NamespacedPodTemplateRequest) returns (IoK8sApiCoreV1PodTemplate);

  rpc DeleteCoreV1NamespacedReplicationController (DeleteCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedResourceQuota (DeleteCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc DeleteCoreV1NamespacedSecret (DeleteCoreV1NamespacedSecretRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1NamespacedService (DeleteCoreV1NamespacedServiceRequest) returns (IoK8sApiCoreV1Service);

  rpc DeleteCoreV1NamespacedServiceAccount (DeleteCoreV1NamespacedServiceAccountRequest) returns (IoK8sApiCoreV1ServiceAccount);

  rpc DeleteCoreV1Node (DeleteCoreV1NodeRequest) returns (IoK8sApimachineryPkgApisMetaV1Status);

  rpc DeleteCoreV1PersistentVolume (DeleteCoreV1PersistentVolumeRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc GetCoreV1APIResources (google.protobuf.Empty) returns (IoK8sApimachineryPkgApisMetaV1APIResourceList);

  rpc ListCoreV1ComponentStatus (ListCoreV1ComponentStatusRequest) returns (IoK8sApiCoreV1ComponentStatusList);

  rpc ListCoreV1ConfigMapForAllNamespaces (ListCoreV1ConfigMapForAllNamespacesRequest) returns (IoK8sApiCoreV1ConfigMapList);

  rpc ListCoreV1EndpointsForAllNamespaces (ListCoreV1EndpointsForAllNamespacesRequest) returns (IoK8sApiCoreV1EndpointsList);

  rpc ListCoreV1EventForAllNamespaces (ListCoreV1EventForAllNamespacesRequest) returns (IoK8sApiCoreV1EventList);

  rpc ListCoreV1LimitRangeForAllNamespaces (ListCoreV1LimitRangeForAllNamespacesRequest) returns (IoK8sApiCoreV1LimitRangeList);

  rpc ListCoreV1Namespace (ListCoreV1NamespaceRequest) returns (IoK8sApiCoreV1NamespaceList);

  rpc ListCoreV1NamespacedConfigMap (ListCoreV1NamespacedConfigMapRequest) returns (IoK8sApiCoreV1ConfigMapList);

  rpc ListCoreV1NamespacedEndpoints (ListCoreV1NamespacedEndpointsRequest) returns (IoK8sApiCoreV1EndpointsList);

  rpc ListCoreV1NamespacedEvent (ListCoreV1NamespacedEventRequest) returns (IoK8sApiCoreV1EventList);

  rpc ListCoreV1NamespacedLimitRange (ListCoreV1NamespacedLimitRangeRequest) returns (IoK8sApiCoreV1LimitRangeList);

  rpc ListCoreV1NamespacedPersistentVolumeClaim (ListCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApiCoreV1PersistentVolumeClaimList);

  rpc ListCoreV1NamespacedPod (ListCoreV1NamespacedPodRequest) returns (IoK8sApiCoreV1PodList);

  rpc ListCoreV1NamespacedPodTemplate (ListCoreV1NamespacedPodTemplateRequest) returns (IoK8sApiCoreV1PodTemplateList);

  rpc ListCoreV1NamespacedReplicationController (ListCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApiCoreV1ReplicationControllerList);

  rpc ListCoreV1NamespacedResourceQuota (ListCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApiCoreV1ResourceQuotaList);

  rpc ListCoreV1NamespacedSecret (ListCoreV1NamespacedSecretRequest) returns (IoK8sApiCoreV1SecretList);

  rpc ListCoreV1NamespacedService (ListCoreV1NamespacedServiceRequest) returns (IoK8sApiCoreV1ServiceList);

  rpc ListCoreV1NamespacedServiceAccount (ListCoreV1NamespacedServiceAccountRequest) returns (IoK8sApiCoreV1ServiceAccountList);

  rpc ListCoreV1Node (ListCoreV1NodeRequest) returns (IoK8sApiCoreV1NodeList);

  rpc ListCoreV1PersistentVolume (ListCoreV1PersistentVolumeRequest) returns (IoK8sApiCoreV1PersistentVolumeList);

  rpc ListCoreV1PersistentVolumeClaimForAllNamespaces (ListCoreV1PersistentVolumeClaimForAllNamespacesRequest) returns (IoK8sApiCoreV1PersistentVolumeClaimList);

  rpc ListCoreV1PodForAllNamespaces (ListCoreV1PodForAllNamespacesRequest) returns (IoK8sApiCoreV1PodList);

  rpc ListCoreV1PodTemplateForAllNamespaces (ListCoreV1PodTemplateForAllNamespacesRequest) returns (IoK8sApiCoreV1PodTemplateList);

  rpc ListCoreV1ReplicationControllerForAllNamespaces (ListCoreV1ReplicationControllerForAllNamespacesRequest) returns (IoK8sApiCoreV1ReplicationControllerList);

  rpc ListCoreV1ResourceQuotaForAllNamespaces (ListCoreV1ResourceQuotaForAllNamespacesRequest) returns (IoK8sApiCoreV1ResourceQuotaList);

  rpc ListCoreV1SecretForAllNamespaces (ListCoreV1SecretForAllNamespacesRequest) returns (IoK8sApiCoreV1SecretList);

  rpc ListCoreV1ServiceAccountForAllNamespaces (ListCoreV1ServiceAccountForAllNamespacesRequest) returns (IoK8sApiCoreV1ServiceAccountList);

  rpc ListCoreV1ServiceForAllNamespaces (ListCoreV1ServiceForAllNamespacesRequest) returns (IoK8sApiCoreV1ServiceList);

  rpc PatchCoreV1Namespace (PatchCoreV1NamespaceRequest) returns (IoK8sApiCoreV1Namespace);

  rpc PatchCoreV1NamespaceStatus (PatchCoreV1NamespaceStatusRequest) returns (IoK8sApiCoreV1Namespace);

  rpc PatchCoreV1NamespacedConfigMap (PatchCoreV1NamespacedConfigMapRequest) returns (IoK8sApiCoreV1ConfigMap);

  rpc PatchCoreV1NamespacedEndpoints (PatchCoreV1NamespacedEndpointsRequest) returns (IoK8sApiCoreV1Endpoints);

  rpc PatchCoreV1NamespacedEvent (PatchCoreV1NamespacedEventRequest) returns (IoK8sApiCoreV1Event);

  rpc PatchCoreV1NamespacedLimitRange (PatchCoreV1NamespacedLimitRangeRequest) returns (IoK8sApiCoreV1LimitRange);

  rpc PatchCoreV1NamespacedPersistentVolumeClaim (PatchCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc PatchCoreV1NamespacedPersistentVolumeClaimStatus (PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc PatchCoreV1NamespacedPod (PatchCoreV1NamespacedPodRequest) returns (IoK8sApiCoreV1Pod);

  rpc PatchCoreV1NamespacedPodEphemeralcontainers (PatchCoreV1NamespacedPodEphemeralcontainersRequest) returns (IoK8sApiCoreV1Pod);

  rpc PatchCoreV1NamespacedPodStatus (PatchCoreV1NamespacedPodStatusRequest) returns (IoK8sApiCoreV1Pod);

  rpc PatchCoreV1NamespacedPodTemplate (PatchCoreV1NamespacedPodTemplateRequest) returns (IoK8sApiCoreV1PodTemplate);

  rpc PatchCoreV1NamespacedReplicationController (PatchCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc PatchCoreV1NamespacedReplicationControllerScale (PatchCoreV1NamespacedReplicationControllerScaleRequest) returns (IoK8sApiAutoscalingV1Scale);

  rpc PatchCoreV1NamespacedReplicationControllerStatus (PatchCoreV1NamespacedReplicationControllerStatusRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc PatchCoreV1NamespacedResourceQuota (PatchCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc PatchCoreV1NamespacedResourceQuotaStatus (PatchCoreV1NamespacedResourceQuotaStatusRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc PatchCoreV1NamespacedSecret (PatchCoreV1NamespacedSecretRequest) returns (IoK8sApiCoreV1Secret);

  rpc PatchCoreV1NamespacedService (PatchCoreV1NamespacedServiceRequest) returns (IoK8sApiCoreV1Service);

  rpc PatchCoreV1NamespacedServiceAccount (PatchCoreV1NamespacedServiceAccountRequest) returns (IoK8sApiCoreV1ServiceAccount);

  rpc PatchCoreV1NamespacedServiceStatus (PatchCoreV1NamespacedServiceStatusRequest) returns (IoK8sApiCoreV1Service);

  rpc PatchCoreV1Node (PatchCoreV1NodeRequest) returns (IoK8sApiCoreV1Node);

  rpc PatchCoreV1NodeStatus (PatchCoreV1NodeStatusRequest) returns (IoK8sApiCoreV1Node);

  rpc PatchCoreV1PersistentVolume (PatchCoreV1PersistentVolumeRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc PatchCoreV1PersistentVolumeStatus (PatchCoreV1PersistentVolumeStatusRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc ReadCoreV1ComponentStatus (ReadCoreV1ComponentStatusRequest) returns (IoK8sApiCoreV1ComponentStatus);

  rpc ReadCoreV1Namespace (ReadCoreV1NamespaceRequest) returns (IoK8sApiCoreV1Namespace);

  rpc ReadCoreV1NamespaceStatus (ReadCoreV1NamespaceStatusRequest) returns (IoK8sApiCoreV1Namespace);

  rpc ReadCoreV1NamespacedConfigMap (ReadCoreV1NamespacedConfigMapRequest) returns (IoK8sApiCoreV1ConfigMap);

  rpc ReadCoreV1NamespacedEndpoints (ReadCoreV1NamespacedEndpointsRequest) returns (IoK8sApiCoreV1Endpoints);

  rpc ReadCoreV1NamespacedEvent (ReadCoreV1NamespacedEventRequest) returns (IoK8sApiCoreV1Event);

  rpc ReadCoreV1NamespacedLimitRange (ReadCoreV1NamespacedLimitRangeRequest) returns (IoK8sApiCoreV1LimitRange);

  rpc ReadCoreV1NamespacedPersistentVolumeClaim (ReadCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc ReadCoreV1NamespacedPersistentVolumeClaimStatus (ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc ReadCoreV1NamespacedPod (ReadCoreV1NamespacedPodRequest) returns (IoK8sApiCoreV1Pod);

  rpc ReadCoreV1NamespacedPodEphemeralcontainers (ReadCoreV1NamespacedPodEphemeralcontainersRequest) returns (IoK8sApiCoreV1Pod);

  rpc ReadCoreV1NamespacedPodLog (ReadCoreV1NamespacedPodLogRequest) returns (ReadCoreV1NamespacedPodLogResponse);

  rpc ReadCoreV1NamespacedPodStatus (ReadCoreV1NamespacedPodStatusRequest) returns (IoK8sApiCoreV1Pod);

  rpc ReadCoreV1NamespacedPodTemplate (ReadCoreV1NamespacedPodTemplateRequest) returns (IoK8sApiCoreV1PodTemplate);

  rpc ReadCoreV1NamespacedReplicationController (ReadCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc ReadCoreV1NamespacedReplicationControllerScale (ReadCoreV1NamespacedReplicationControllerScaleRequest) returns (IoK8sApiAutoscalingV1Scale);

  rpc ReadCoreV1NamespacedReplicationControllerStatus (ReadCoreV1NamespacedReplicationControllerStatusRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc ReadCoreV1NamespacedResourceQuota (ReadCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc ReadCoreV1NamespacedResourceQuotaStatus (ReadCoreV1NamespacedResourceQuotaStatusRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc ReadCoreV1NamespacedSecret (ReadCoreV1NamespacedSecretRequest) returns (IoK8sApiCoreV1Secret);

  rpc ReadCoreV1NamespacedService (ReadCoreV1NamespacedServiceRequest) returns (IoK8sApiCoreV1Service);

  rpc ReadCoreV1NamespacedServiceAccount (ReadCoreV1NamespacedServiceAccountRequest) returns (IoK8sApiCoreV1ServiceAccount);

  rpc ReadCoreV1NamespacedServiceStatus (ReadCoreV1NamespacedServiceStatusRequest) returns (IoK8sApiCoreV1Service);

  rpc ReadCoreV1Node (ReadCoreV1NodeRequest) returns (IoK8sApiCoreV1Node);

  rpc ReadCoreV1NodeStatus (ReadCoreV1NodeStatusRequest) returns (IoK8sApiCoreV1Node);

  rpc ReadCoreV1PersistentVolume (ReadCoreV1PersistentVolumeRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc ReadCoreV1PersistentVolumeStatus (ReadCoreV1PersistentVolumeStatusRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc ReplaceCoreV1Namespace (ReplaceCoreV1NamespaceRequest) returns (IoK8sApiCoreV1Namespace);

  rpc ReplaceCoreV1NamespaceFinalize (ReplaceCoreV1NamespaceFinalizeRequest) returns (IoK8sApiCoreV1Namespace);

  rpc ReplaceCoreV1NamespaceStatus (ReplaceCoreV1NamespaceStatusRequest) returns (IoK8sApiCoreV1Namespace);

  rpc ReplaceCoreV1NamespacedConfigMap (ReplaceCoreV1NamespacedConfigMapRequest) returns (IoK8sApiCoreV1ConfigMap);

  rpc ReplaceCoreV1NamespacedEndpoints (ReplaceCoreV1NamespacedEndpointsRequest) returns (IoK8sApiCoreV1Endpoints);

  rpc ReplaceCoreV1NamespacedEvent (ReplaceCoreV1NamespacedEventRequest) returns (IoK8sApiCoreV1Event);

  rpc ReplaceCoreV1NamespacedLimitRange (ReplaceCoreV1NamespacedLimitRangeRequest) returns (IoK8sApiCoreV1LimitRange);

  rpc ReplaceCoreV1NamespacedPersistentVolumeClaim (ReplaceCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc ReplaceCoreV1NamespacedPersistentVolumeClaimStatus (ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest) returns (IoK8sApiCoreV1PersistentVolumeClaim);

  rpc ReplaceCoreV1NamespacedPod (ReplaceCoreV1NamespacedPodRequest) returns (IoK8sApiCoreV1Pod);

  rpc ReplaceCoreV1NamespacedPodEphemeralcontainers (ReplaceCoreV1NamespacedPodEphemeralcontainersRequest) returns (IoK8sApiCoreV1Pod);

  rpc ReplaceCoreV1NamespacedPodStatus (ReplaceCoreV1NamespacedPodStatusRequest) returns (IoK8sApiCoreV1Pod);

  rpc ReplaceCoreV1NamespacedPodTemplate (ReplaceCoreV1NamespacedPodTemplateRequest) returns (IoK8sApiCoreV1PodTemplate);

  rpc ReplaceCoreV1NamespacedReplicationController (ReplaceCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc ReplaceCoreV1NamespacedReplicationControllerScale (ReplaceCoreV1NamespacedReplicationControllerScaleRequest) returns (IoK8sApiAutoscalingV1Scale);

  rpc ReplaceCoreV1NamespacedReplicationControllerStatus (ReplaceCoreV1NamespacedReplicationControllerStatusRequest) returns (IoK8sApiCoreV1ReplicationController);

  rpc ReplaceCoreV1NamespacedResourceQuota (ReplaceCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc ReplaceCoreV1NamespacedResourceQuotaStatus (ReplaceCoreV1NamespacedResourceQuotaStatusRequest) returns (IoK8sApiCoreV1ResourceQuota);

  rpc ReplaceCoreV1NamespacedSecret (ReplaceCoreV1NamespacedSecretRequest) returns (IoK8sApiCoreV1Secret);

  rpc ReplaceCoreV1NamespacedService (ReplaceCoreV1NamespacedServiceRequest) returns (IoK8sApiCoreV1Service);

  rpc ReplaceCoreV1NamespacedServiceAccount (ReplaceCoreV1NamespacedServiceAccountRequest) returns (IoK8sApiCoreV1ServiceAccount);

  rpc ReplaceCoreV1NamespacedServiceStatus (ReplaceCoreV1NamespacedServiceStatusRequest) returns (IoK8sApiCoreV1Service);

  rpc ReplaceCoreV1Node (ReplaceCoreV1NodeRequest) returns (IoK8sApiCoreV1Node);

  rpc ReplaceCoreV1NodeStatus (ReplaceCoreV1NodeStatusRequest) returns (IoK8sApiCoreV1Node);

  rpc ReplaceCoreV1PersistentVolume (ReplaceCoreV1PersistentVolumeRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc ReplaceCoreV1PersistentVolumeStatus (ReplaceCoreV1PersistentVolumeStatusRequest) returns (IoK8sApiCoreV1PersistentVolume);

  rpc WatchCoreV1ConfigMapListForAllNamespaces (WatchCoreV1ConfigMapListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1EndpointsListForAllNamespaces (WatchCoreV1EndpointsListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1EventListForAllNamespaces (WatchCoreV1EventListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1LimitRangeListForAllNamespaces (WatchCoreV1LimitRangeListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1Namespace (WatchCoreV1NamespaceRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespaceList (WatchCoreV1NamespaceListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedConfigMap (WatchCoreV1NamespacedConfigMapRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedConfigMapList (WatchCoreV1NamespacedConfigMapListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedEndpoints (WatchCoreV1NamespacedEndpointsRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedEndpointsList (WatchCoreV1NamespacedEndpointsListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedEvent (WatchCoreV1NamespacedEventRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedEventList (WatchCoreV1NamespacedEventListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedLimitRange (WatchCoreV1NamespacedLimitRangeRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedLimitRangeList (WatchCoreV1NamespacedLimitRangeListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedPersistentVolumeClaim (WatchCoreV1NamespacedPersistentVolumeClaimRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedPersistentVolumeClaimList (WatchCoreV1NamespacedPersistentVolumeClaimListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedPod (WatchCoreV1NamespacedPodRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedPodList (WatchCoreV1NamespacedPodListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedPodTemplate (WatchCoreV1NamespacedPodTemplateRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedPodTemplateList (WatchCoreV1NamespacedPodTemplateListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedReplicationController (WatchCoreV1NamespacedReplicationControllerRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedReplicationControllerList (WatchCoreV1NamespacedReplicationControllerListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedResourceQuota (WatchCoreV1NamespacedResourceQuotaRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedResourceQuotaList (WatchCoreV1NamespacedResourceQuotaListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedSecret (WatchCoreV1NamespacedSecretRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedSecretList (WatchCoreV1NamespacedSecretListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedService (WatchCoreV1NamespacedServiceRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedServiceAccount (WatchCoreV1NamespacedServiceAccountRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedServiceAccountList (WatchCoreV1NamespacedServiceAccountListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NamespacedServiceList (WatchCoreV1NamespacedServiceListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1Node (WatchCoreV1NodeRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1NodeList (WatchCoreV1NodeListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1PersistentVolume (WatchCoreV1PersistentVolumeRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1PersistentVolumeClaimListForAllNamespaces (WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1PersistentVolumeList (WatchCoreV1PersistentVolumeListRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1PodListForAllNamespaces (WatchCoreV1PodListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1PodTemplateListForAllNamespaces (WatchCoreV1PodTemplateListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1ReplicationControllerListForAllNamespaces (WatchCoreV1ReplicationControllerListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1ResourceQuotaListForAllNamespaces (WatchCoreV1ResourceQuotaListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1SecretListForAllNamespaces (WatchCoreV1SecretListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1ServiceAccountListForAllNamespaces (WatchCoreV1ServiceAccountListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

  rpc WatchCoreV1ServiceListForAllNamespaces (WatchCoreV1ServiceListForAllNamespacesRequest) returns (IoK8sApimachineryPkgApisMetaV1WatchEvent);

}

message ConnectCoreV1DeleteNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1DeleteNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1DeleteNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1DeleteNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1DeleteNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1DeleteNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1DeleteNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1DeleteNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1DeleteNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1DeleteNodeProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedPodAttachRequest {
  // name of the PodAttachOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // The container in which to execute the command. Defaults to only container if there is only one container in the pod.
  string container = 3;
  // Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
  bool stderr = 4;
  // Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
  bool stdin = 5;
  // Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
  bool stdout = 6;
  // TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
  bool tty = 7;

}

message ConnectCoreV1GetNamespacedPodAttachResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedPodExecRequest {
  // name of the PodExecOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Command is the remote command to execute. argv array. Not executed within a shell.
  string command = 3;
  // Container in which to execute the command. Defaults to only container if there is only one container in the pod.
  string container = 4;
  // Redirect the standard error stream of the pod for this call.
  bool stderr = 5;
  // Redirect the standard input stream of the pod for this call. Defaults to false.
  bool stdin = 6;
  // Redirect the standard output stream of the pod for this call.
  bool stdout = 7;
  // TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
  bool tty = 8;

}

message ConnectCoreV1GetNamespacedPodExecResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedPodPortforwardRequest {
  // name of the PodPortForwardOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // List of ports to forward Required when using WebSockets
  int32 ports = 3;

}

message ConnectCoreV1GetNamespacedPodPortforwardResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1GetNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1GetNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1GetNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1GetNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1GetNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1GetNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1GetNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1GetNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1GetNodeProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1HeadNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1HeadNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1HeadNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1HeadNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1HeadNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1HeadNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1HeadNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1HeadNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1HeadNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1HeadNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1HeadNodeProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1OptionsNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1OptionsNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1OptionsNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1OptionsNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1OptionsNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1OptionsNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1OptionsNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1OptionsNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1OptionsNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1OptionsNodeProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PatchNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1PatchNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1PatchNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1PatchNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PatchNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1PatchNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1PatchNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PatchNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1PatchNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1PatchNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1PatchNodeProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedPodAttachRequest {
  // name of the PodAttachOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // The container in which to execute the command. Defaults to only container if there is only one container in the pod.
  string container = 3;
  // Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
  bool stderr = 4;
  // Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
  bool stdin = 5;
  // Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
  bool stdout = 6;
  // TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
  bool tty = 7;

}

message ConnectCoreV1PostNamespacedPodAttachResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedPodExecRequest {
  // name of the PodExecOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Command is the remote command to execute. argv array. Not executed within a shell.
  string command = 3;
  // Container in which to execute the command. Defaults to only container if there is only one container in the pod.
  string container = 4;
  // Redirect the standard error stream of the pod for this call.
  bool stderr = 5;
  // Redirect the standard input stream of the pod for this call. Defaults to false.
  bool stdin = 6;
  // Redirect the standard output stream of the pod for this call.
  bool stdout = 7;
  // TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
  bool tty = 8;

}

message ConnectCoreV1PostNamespacedPodExecResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedPodPortforwardRequest {
  // name of the PodPortForwardOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // List of ports to forward Required when using WebSockets
  int32 ports = 3;

}

message ConnectCoreV1PostNamespacedPodPortforwardResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1PostNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1PostNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1PostNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1PostNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1PostNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PostNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1PostNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1PostNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1PostNodeProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PutNamespacedPodProxyRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the URL path to use for the current proxy request to pod.
  string path = 3;

}

message ConnectCoreV1PutNamespacedPodProxyResponse {
  string data = 1;
}

message ConnectCoreV1PutNamespacedPodProxyWithPathRequest {
  // name of the PodProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the URL path to use for the current proxy request to pod.
  string path2 = 4;

}

message ConnectCoreV1PutNamespacedPodProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PutNamespacedServiceProxyRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path = 3;

}

message ConnectCoreV1PutNamespacedServiceProxyResponse {
  string data = 1;
}

message ConnectCoreV1PutNamespacedServiceProxyWithPathRequest {
  // name of the ServiceProxyOptions
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // path to the resource
  string path = 3;
  // Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
  string path2 = 4;

}

message ConnectCoreV1PutNamespacedServiceProxyWithPathResponse {
  string data = 1;
}

message ConnectCoreV1PutNodeProxyRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // Path is the URL path to use for the current proxy request to node.
  string path = 2;

}

message ConnectCoreV1PutNodeProxyResponse {
  string data = 1;
}

message ConnectCoreV1PutNodeProxyWithPathRequest {
  // name of the NodeProxyOptions
  string name = 1;
  // path to the resource
  string path = 2;
  // Path is the URL path to use for the current proxy request to node.
  string path2 = 3;

}

message ConnectCoreV1PutNodeProxyWithPathResponse {
  string data = 1;
}

message CreateCoreV1NamespaceRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 2;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 3;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 4;
  IoK8sApiCoreV1Namespace ioK8sApiCoreV1Namespace = 5;

}

message CreateCoreV1NamespacedBindingRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 2;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 3;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 4;
  // If 'true', then the output is pretty printed.
  string pretty = 5;
  IoK8sApiCoreV1Binding ioK8sApiCoreV1Binding = 6;

}

message CreateCoreV1NamespacedConfigMapRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1ConfigMap ioK8sApiCoreV1ConfigMap = 6;

}

message CreateCoreV1NamespacedEndpointsRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Endpoints ioK8sApiCoreV1Endpoints = 6;

}

message CreateCoreV1NamespacedEventRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Event ioK8sApiCoreV1Event = 6;

}

message CreateCoreV1NamespacedLimitRangeRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1LimitRange ioK8sApiCoreV1LimitRange = 6;

}

message CreateCoreV1NamespacedPersistentVolumeClaimRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1PersistentVolumeClaim ioK8sApiCoreV1PersistentVolumeClaim = 6;

}

message CreateCoreV1NamespacedPodRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Pod ioK8sApiCoreV1Pod = 6;

}

message CreateCoreV1NamespacedPodBindingRequest {
  // name of the Binding
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  IoK8sApiCoreV1Binding ioK8sApiCoreV1Binding = 7;

}

message CreateCoreV1NamespacedPodEvictionRequest {
  // name of the Eviction
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  IoK8sApiPolicyV1Eviction ioK8sApiPolicyV1Eviction = 7;

}

message CreateCoreV1NamespacedPodTemplateRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1PodTemplate ioK8sApiCoreV1PodTemplate = 6;

}

message CreateCoreV1NamespacedReplicationControllerRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1ReplicationController ioK8sApiCoreV1ReplicationController = 6;

}

message CreateCoreV1NamespacedResourceQuotaRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1ResourceQuota ioK8sApiCoreV1ResourceQuota = 6;

}

message CreateCoreV1NamespacedSecretRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Secret ioK8sApiCoreV1Secret = 6;

}

message CreateCoreV1NamespacedServiceRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Service ioK8sApiCoreV1Service = 6;

}

message CreateCoreV1NamespacedServiceAccountRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1ServiceAccount ioK8sApiCoreV1ServiceAccount = 6;

}

message CreateCoreV1NamespacedServiceAccountTokenRequest {
  // name of the TokenRequest
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  IoK8sApiAuthenticationV1TokenRequest ioK8sApiAuthenticationV1TokenRequest = 7;

}

message CreateCoreV1NodeRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 2;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 3;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 4;
  IoK8sApiCoreV1Node ioK8sApiCoreV1Node = 5;

}

message CreateCoreV1PersistentVolumeRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 2;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 3;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 4;
  IoK8sApiCoreV1PersistentVolume ioK8sApiCoreV1PersistentVolume = 5;

}

message DeleteCoreV1CollectionNamespacedConfigMapRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedEndpointsRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedEventRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedLimitRangeRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedPodRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedPodTemplateRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedReplicationControllerRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedResourceQuotaRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedSecretRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedServiceRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNamespacedServiceAccountRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 6;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 7;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 8;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 9;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 10;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 11;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 12;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 13;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 14;

}

message DeleteCoreV1CollectionNodeRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 8;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 9;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 10;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 11;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 12;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 13;

}

message DeleteCoreV1CollectionPersistentVolumeRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 8;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 9;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 10;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 11;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 12;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 13;

}

message DeleteCoreV1NamespaceRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 4;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 5;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 6;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 7;

}

message DeleteCoreV1NamespacedConfigMapRequest {
  // name of the ConfigMap
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedEndpointsRequest {
  // name of the Endpoints
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedEventRequest {
  // name of the Event
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedLimitRangeRequest {
  // name of the LimitRange
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedPersistentVolumeClaimRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedPodRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedPodTemplateRequest {
  // name of the PodTemplate
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedReplicationControllerRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedResourceQuotaRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedSecretRequest {
  // name of the Secret
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedServiceRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NamespacedServiceAccountRequest {
  // name of the ServiceAccount
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 5;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 6;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 7;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 8;

}

message DeleteCoreV1NodeRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 4;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 5;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 6;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 7;

}

message DeleteCoreV1PersistentVolumeRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
  int32 gracePeriodSeconds = 4;
  // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
  bool orphanDependents = 5;
  // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
  string propagationPolicy = 6;
  IoK8sApimachineryPkgApisMetaV1DeleteOptions ioK8sApimachineryPkgApisMetaV1DeleteOptions = 7;

}

message ListCoreV1ComponentStatusRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1ConfigMapForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1EndpointsForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1EventForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1LimitRangeForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1NamespaceRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1NamespacedConfigMapRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedEndpointsRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedEventRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedLimitRangeRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedPersistentVolumeClaimRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedPodRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedPodTemplateRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedReplicationControllerRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedResourceQuotaRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedSecretRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedServiceRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NamespacedServiceAccountRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message ListCoreV1NodeRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1PersistentVolumeRequest {
  // If 'true', then the output is pretty printed.
  string pretty = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1PersistentVolumeClaimForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1PodForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1PodTemplateForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1ReplicationControllerForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1ResourceQuotaForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1SecretForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1ServiceAccountForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message ListCoreV1ServiceForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message PatchCoreV1NamespaceRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 6;
  google.protobuf.Struct body = 7;

}

message PatchCoreV1NamespaceStatusRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 6;
  google.protobuf.Struct body = 7;

}

message PatchCoreV1NamespacedConfigMapRequest {
  // name of the ConfigMap
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedEndpointsRequest {
  // name of the Endpoints
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedEventRequest {
  // name of the Event
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedLimitRangeRequest {
  // name of the LimitRange
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedPersistentVolumeClaimRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedPodRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedPodEphemeralcontainersRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedPodStatusRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedPodTemplateRequest {
  // name of the PodTemplate
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedReplicationControllerRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedReplicationControllerScaleRequest {
  // name of the Scale
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedReplicationControllerStatusRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedResourceQuotaRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedResourceQuotaStatusRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedSecretRequest {
  // name of the Secret
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedServiceRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedServiceAccountRequest {
  // name of the ServiceAccount
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NamespacedServiceStatusRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 7;
  google.protobuf.Struct body = 8;

}

message PatchCoreV1NodeRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 6;
  google.protobuf.Struct body = 7;

}

message PatchCoreV1NodeStatusRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 6;
  google.protobuf.Struct body = 7;

}

message PatchCoreV1PersistentVolumeRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 6;
  google.protobuf.Struct body = 7;

}

message PatchCoreV1PersistentVolumeStatusRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  // Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
  bool force = 6;
  google.protobuf.Struct body = 7;

}

message ReadCoreV1ComponentStatusRequest {
  // name of the ComponentStatus
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReadCoreV1NamespaceRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReadCoreV1NamespaceStatusRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReadCoreV1NamespacedConfigMapRequest {
  // name of the ConfigMap
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedEndpointsRequest {
  // name of the Endpoints
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedEventRequest {
  // name of the Event
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedLimitRangeRequest {
  // name of the LimitRange
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedPersistentVolumeClaimRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedPodRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedPodEphemeralcontainersRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedPodLogRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // The container for which to stream logs. Defaults to only container if there is one container in the pod.
  string container = 3;
  // Follow the log stream of the pod. Defaults to false.
  bool follow = 4;
  // insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).
  bool insecureSkipTLSVerifyBackend = 5;
  // If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
  int32 limitBytes = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // Return previous terminated container logs. Defaults to false.
  bool previous = 8;
  // A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
  int32 sinceSeconds = 9;
  // If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
  int32 tailLines = 10;
  // If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
  bool timestamps = 11;

}

message ReadCoreV1NamespacedPodLogResponse {
  string data = 1;
}

message ReadCoreV1NamespacedPodStatusRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedPodTemplateRequest {
  // name of the PodTemplate
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedReplicationControllerRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedReplicationControllerScaleRequest {
  // name of the Scale
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedReplicationControllerStatusRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedResourceQuotaRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedResourceQuotaStatusRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedSecretRequest {
  // name of the Secret
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedServiceRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedServiceAccountRequest {
  // name of the ServiceAccount
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NamespacedServiceStatusRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;

}

message ReadCoreV1NodeRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReadCoreV1NodeStatusRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReadCoreV1PersistentVolumeRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReadCoreV1PersistentVolumeStatusRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;

}

message ReplaceCoreV1NamespaceRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Namespace ioK8sApiCoreV1Namespace = 6;

}

message ReplaceCoreV1NamespaceFinalizeRequest {
  // name of the Namespace
  string name = 1;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 2;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 3;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 4;
  // If 'true', then the output is pretty printed.
  string pretty = 5;
  IoK8sApiCoreV1Namespace ioK8sApiCoreV1Namespace = 6;

}

message ReplaceCoreV1NamespaceStatusRequest {
  // name of the Namespace
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Namespace ioK8sApiCoreV1Namespace = 6;

}

message ReplaceCoreV1NamespacedConfigMapRequest {
  // name of the ConfigMap
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1ConfigMap ioK8sApiCoreV1ConfigMap = 7;

}

message ReplaceCoreV1NamespacedEndpointsRequest {
  // name of the Endpoints
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Endpoints ioK8sApiCoreV1Endpoints = 7;

}

message ReplaceCoreV1NamespacedEventRequest {
  // name of the Event
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Event ioK8sApiCoreV1Event = 7;

}

message ReplaceCoreV1NamespacedLimitRangeRequest {
  // name of the LimitRange
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1LimitRange ioK8sApiCoreV1LimitRange = 7;

}

message ReplaceCoreV1NamespacedPersistentVolumeClaimRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1PersistentVolumeClaim ioK8sApiCoreV1PersistentVolumeClaim = 7;

}

message ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1PersistentVolumeClaim ioK8sApiCoreV1PersistentVolumeClaim = 7;

}

message ReplaceCoreV1NamespacedPodRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Pod ioK8sApiCoreV1Pod = 7;

}

message ReplaceCoreV1NamespacedPodEphemeralcontainersRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Pod ioK8sApiCoreV1Pod = 7;

}

message ReplaceCoreV1NamespacedPodStatusRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Pod ioK8sApiCoreV1Pod = 7;

}

message ReplaceCoreV1NamespacedPodTemplateRequest {
  // name of the PodTemplate
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1PodTemplate ioK8sApiCoreV1PodTemplate = 7;

}

message ReplaceCoreV1NamespacedReplicationControllerRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1ReplicationController ioK8sApiCoreV1ReplicationController = 7;

}

message ReplaceCoreV1NamespacedReplicationControllerScaleRequest {
  // name of the Scale
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiAutoscalingV1Scale ioK8sApiAutoscalingV1Scale = 7;

}

message ReplaceCoreV1NamespacedReplicationControllerStatusRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1ReplicationController ioK8sApiCoreV1ReplicationController = 7;

}

message ReplaceCoreV1NamespacedResourceQuotaRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1ResourceQuota ioK8sApiCoreV1ResourceQuota = 7;

}

message ReplaceCoreV1NamespacedResourceQuotaStatusRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1ResourceQuota ioK8sApiCoreV1ResourceQuota = 7;

}

message ReplaceCoreV1NamespacedSecretRequest {
  // name of the Secret
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Secret ioK8sApiCoreV1Secret = 7;

}

message ReplaceCoreV1NamespacedServiceRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Service ioK8sApiCoreV1Service = 7;

}

message ReplaceCoreV1NamespacedServiceAccountRequest {
  // name of the ServiceAccount
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1ServiceAccount ioK8sApiCoreV1ServiceAccount = 7;

}

message ReplaceCoreV1NamespacedServiceStatusRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // If 'true', then the output is pretty printed.
  string pretty = 3;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 4;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 5;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 6;
  IoK8sApiCoreV1Service ioK8sApiCoreV1Service = 7;

}

message ReplaceCoreV1NodeRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Node ioK8sApiCoreV1Node = 6;

}

message ReplaceCoreV1NodeStatusRequest {
  // name of the Node
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1Node ioK8sApiCoreV1Node = 6;

}

message ReplaceCoreV1PersistentVolumeRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1PersistentVolume ioK8sApiCoreV1PersistentVolume = 6;

}

message ReplaceCoreV1PersistentVolumeStatusRequest {
  // name of the PersistentVolume
  string name = 1;
  // If 'true', then the output is pretty printed.
  string pretty = 2;
  // When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
  string dryRun = 3;
  // fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
  string fieldManager = 4;
  // fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
  string fieldValidation = 5;
  IoK8sApiCoreV1PersistentVolume ioK8sApiCoreV1PersistentVolume = 6;

}

message WatchCoreV1ConfigMapListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1EndpointsListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1EventListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1LimitRangeListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1NamespaceRequest {
  // name of the Namespace
  string name = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespaceListRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1NamespacedConfigMapRequest {
  // name of the ConfigMap
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedConfigMapListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedEndpointsRequest {
  // name of the Endpoints
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedEndpointsListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedEventRequest {
  // name of the Event
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedEventListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedLimitRangeRequest {
  // name of the LimitRange
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedLimitRangeListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedPersistentVolumeClaimRequest {
  // name of the PersistentVolumeClaim
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedPersistentVolumeClaimListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedPodRequest {
  // name of the Pod
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedPodListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedPodTemplateRequest {
  // name of the PodTemplate
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedPodTemplateListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedReplicationControllerRequest {
  // name of the ReplicationController
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedReplicationControllerListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedResourceQuotaRequest {
  // name of the ResourceQuota
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedResourceQuotaListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedSecretRequest {
  // name of the Secret
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedSecretListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedServiceRequest {
  // name of the Service
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedServiceAccountRequest {
  // name of the ServiceAccount
  string name = 1;
  // object name and auth scope, such as for teams and projects
  string namespace = 2;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 3;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 4;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 5;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 6;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 7;
  // If 'true', then the output is pretty printed.
  string pretty = 8;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 9;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 10;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 11;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 12;

}

message WatchCoreV1NamespacedServiceAccountListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NamespacedServiceListRequest {
  // object name and auth scope, such as for teams and projects
  string namespace = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NodeRequest {
  // name of the Node
  string name = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1NodeListRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1PersistentVolumeRequest {
  // name of the PersistentVolume
  string name = 1;
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 2;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 3;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 4;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 5;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 6;
  // If 'true', then the output is pretty printed.
  string pretty = 7;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 8;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 9;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 10;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 11;

}

message WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1PersistentVolumeListRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1PodListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1PodTemplateListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1ReplicationControllerListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1ResourceQuotaListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1SecretListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1ServiceAccountListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}

message WatchCoreV1ServiceListForAllNamespacesRequest {
  // allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
  bool allowWatchBookmarks = 1;
  // The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
  string continue = 2;
  // A selector to restrict the list of returned objects by their fields. Defaults to everything.
  string fieldSelector = 3;
  // A selector to restrict the list of returned objects by their labels. Defaults to everything.
  string labelSelector = 4;
  // limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
  int32 limit = 5;
  // If 'true', then the output is pretty printed.
  string pretty = 6;
  // resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersion = 7;
  // resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
  string resourceVersionMatch = 8;
  // Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
  int32 timeoutSeconds = 9;
  // Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
  bool watch = 10;

}
